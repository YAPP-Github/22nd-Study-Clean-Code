# 동시성

객체는 처리의 추상화다. 스레드는 일정의 추상화다.

이 장에서는 여러 스레드를 동시에 돌리는 이유를 논하고, 여러 스레드를 동시에 돌리는 어려움도 논한다. 그리고 이런 어려움에 대처하고 깨끗한 코드를 작성하는 방법도 몇 가지 제안한다.

<br />

## 동시성이 필요한 이유?

동시성은 결합(coupling)을 없애는 전략이다. 즉 `무엇`과 `언제`를 분리하는 전략이다. `무엇`과 `언제`를 분리하면 애플리케이션 구조와 효율이 극적으로 나아진다.

웹 어플리케이션이 표준으로 사용하는 서블릿(Servlet) 모델은 각 스레드가 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아간다. 하지만 동시성은 이렇게 간단한 문제가 아니다.

<br />

## 미신과 오해

- 동시성은 향상 성능을 높여준다.
- 동시성은 때로 성능을 높여준다.
- 동시성을 구현해도 설계는 변하지 않는다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.

<br />

## 동시성과 관련된 타당한 생각

- 동시성은 다소 부하를 유발한다.
- 동시성은 간단한 문제라도 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.

<br />

## 동시성 방어 원칙

### 단일 책임 원칙(Single Responsibility Principle, SRP)

SRP는 주어진 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다는 원칙이다. 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다. 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다.

- 권장사항: 동시성 코드는 다른 코드와 분리하라.

<br />

### 정리: 자료 범위를 제한하라

공유 객체를 사용하는 코드 내 임계 영역을 synchronized 키워드로 보호하라고 권장한다. 이런 임계영역의 수를 줄이는 기술이 중요하다.

- 권장사항: 자료를 캡슐화하라. 공유 자료를 최대한 줄여라.

<br />

### 정리: 자료 사본을 사용하라

공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다. 객체를 복사해서 읽기 전용으로 사용하거나, 각 스레드가 객체를 복사해서 사용한 후 다른 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다.

<br />

### 정리: 스레드는 가능한 독립적으로 구현하라

자신만의 세상에 존재하는 스레드를 구현한다. 각 스레드는 클라이언트 요청 하나를 처리한다.

- 권장사항: 자료를 독립적인 단위로 분할하라.

<br />

## 라이브러리를 이해하라

사용하는 라이브러리에서 버전마다 제공하는 기능을 잘 이해하고 사용하라.

<br />

## 실행 모델을 이해하라

다중 스레드 애플리케이션을 분류하는 방식은 여러 가지다.

|한정된 자원|다중 스레드 환경에서 사용하는 자원은 크기나 숫자가 제한적이다. (ex. DB 연결, 버퍼)|
|상호 배제(Mutual Exclusion)|한 번에 한 스레드만 공유|
|기아(Starvation)|한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다.|
|데드락(Deadlock)|여러 스레드가 서로가 끝나기를 기다린다.|
|라이브락(Livelock)|락을 거는 단계에서 각 스레드가 서로를 방해한다. 공명(resonance)으로 인해, 진행하지 못한다.|

<br />

### 생산자-소비자

하나 이상 `생산자 스레드`가 정보를 생성해 버퍼나 대기열에 넣는다. 하나 이상 `소비자 스레드`가 대기열에서 정보를 가져와 사용한다. 대기열은 한정된 자원이다. 생산자 스레드는 빈 공간이 생길 때까지 기다리며, 공간이 생기면 정보를 채운다.

잘못할 경우 생산자 스레드와 소비자 스레드가 둘 다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성이 존재한다.

<br />

### 읽기-쓰기

읽기 쓰레드를 위한 주된 정보원으로 공유 자원을 사용하지만, 쓰기 스레드가 이 공유 자원을 갱신한다고 하자. 이런 경우 처리율(throughput)이 문제의 핵심이다. 대개는 쓰기 스레드가 버퍼를 오랫동안 정유하는 바람에 여러 읽기 쓰레드가 버퍼를 기다리느라 처리율이 떨어진다.

간단한 전략은 읽기 스레드가 없을 때까지 갱신을 원하는 쓰기 스레드가 버퍼를 기다리는 방법이다. 반면, 쓰기 스레드에게 우선권을 준 상태에서 쓰기 스레드가 계속 이어진다면 처리율이 떨어진다. 양쪽 균형을 잡으면서 동시 갱신 문제를 피하는 해법이 필요하다.

<br />

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

동기화하는 메서드 사이에 의존성이 존재하면 동시성 코드에 찾아내기 어려운 버그가 생긴다. 공유 클래스 하나에 동기화된 메서드(synchronized)가 여럿이라면 구현이 올바른지 다시 한 번 확인하기 바란다.

- 권장사항: 공유 객체 하나에는 메서드 하나만 사용하라.

<br />

## 동기화하는 부분을 작게 만들어라

자바에서 synchronized 키워드를 사용하면 락을 설정한다. 같은 락으로 감싼 모든 코드 영역은 한 번에 한 스레드만 실행이 가능하다. 락은 스레드를 지연시키고 부하를 가중시킨다. 그러므로 synchronized 문을 남발하는 코드는 좋지 않다.

반면, 임계영역은 반드시 보호해야 한다. 따라서, 코드를 짤 때는 임계영역 수를 최대한 줄여야 한다.

- 권장사항: 동기화하는 부분을 최대한 작게 만들어라
