# 냄새와 휴리스틱

## 환경

### E1: 여러 단계로 빌드해야 한다

빌드는 간단히 한 단계로 끝나야 한다. 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

### E2: 여러 단계로 테스트해야 한다

모든 단위 테스트는 한 명령으로 돌려야 한다. 테스트를 한 번에 실행하는건 아주 근본적이고 당연하며, 빠르고 쉬워야 한다.

<br />

## 함수

### F1: 너무 많은 인수

함수에서 인수 개수는 작을수록 좋다. 아예 없으면 가장 좋다.

### F2: 출력 인수

함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

### F3: 플래그 인수

boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다. 플래그 인수는 혼란을 초래하므로 피해야 마땅하다.

### F4: 죽은 함수

아무도 호출하지 않는 함수는 삭제한다. 과감히 삭제하라.

<br />

## 일반

### G1: 한 소스 파일에 여러 언어를 사용한다

이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.

### G2: 당연한 동작을 구현하지 않는다

함수나 클래는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.

### G3: 경계를 올바르게 처리하지 않는다

코드는 올바르게 동작해야 한다. 너무나도 당연한 말이다. 올바른 동작은 아주 복잡하다는 사실을 우리는 자주 간과한다.

### G4: 안전 절차 무시

컴파일러 경고 일부를 꺼버리면 빌드가 쉬워질 수 있으나 끝없는 디버깅 세계에 빠질 수 있다. 실패하는 테스트를 일단 뒤로 미뤄두는 것은 좋지 않다.

### G5: 중복

이 책에 나오는 가장 중요한 규칙 중 하나이므로 심각하게 숙고하기를 바란다. 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라. (DRY 원칙)

### G6: 추상화 수준이 올바르지 못하다

추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다. 추상화는 소프트웨어 개발자에게 가장 어려운 작업 중 하나다.

### G7: 기초 클래스가 파생 클래스에 의존한다

기초클래스는 파생 클래스의 개념으로부터 독립적이어야하며, 파생 클래스에 대해 아예 몰라야 한다. 컴포넌트를 변경한다면 해당 컴포넌트만 다시 배치하면 된다. 기초 컴포넌트까지 다시 배치할 필요가 없다.

### G8: 과도한 정보

잘 정의된 모듈은 인터페이스가 아주 작다. 하지만 작은 인터페이스로도 많은 동작이 가능하다. 자료, 유틸함수, 클래스, 메서드 그리고 상수 변수까지 모두 숨겨라. 인터페이스를 매우 작게 그리고 매우 깐깐하게 만들어라. 정보를 제한해 결합도를 낮춰라.

### G9: 죽은 코드

죽은 코드란 실행되지 않는 코드를 가리킨다. 불가능한 조건을 확인하는 if 문, throw 문이 없는 try 문에서 catch 블록 등 죽은 코드를 발견하면 장례식을 치뤄주라.

### G13: 인위적 결합

서로 무관한 개념을 인위적으로 결합하지 않는다. 예를 들어, 일반적인 enum은 특정 클래스에 속할 이유가 없다. 함수, 상수, 변수를 선언할 때는 시간을 들여 올바른 위치를 고민한다. 그저 당장 편한 곳에 선언하고 내버려두면 안 된다.

### G23: If/Else 혹은 Switch/Case 문보다 다형성을 사용하라

3장에서는 새 유형을 추가할 확률보다 새 함수를 추가할 확률이 높은 코드에서는 switch 문이 더 적합하다고 주장했다. 저자는 'switch 문 하나' 규칙을 따른다. 선택 유형 하나에는 switch 문을 한 번만 사용한다.

같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해 switch 문을 대신한다.

### G28: 조건을 캡슐화해라

Boolean 논리는 이해하기 어렵다. 조건의 의도를 분명히 밝히는 함수로 표현하라.

```tsx
// Bad ❌
if (timer.hasExpired() && !timer.isRecurrent())

// Good ✅
if (shouldBeDeleted(timer))
```

### G29: 부정 조건은 피해라

부정 조건은 긍정 조건보다 이해하기 어렵다. 가능하면 긍정 조건으로 표현한다.

```tsx
// Bad ❌
if (!buffer.shouldCompact())

// Good ✅
if (buffer.shouldCompact())
```

<br />

## 이름

### N1: 서술적인 이름을 사용하라

소프트웨어 가독성의 90%는 이름이 결정한다.

### N2: 적절한 추상화 수준에서 이름을 선택하라

구현을 드러내는 이름은 피하라. 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라

### N7: 이름으로 부수 효과를 설명하라

함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용하라. (get -> createOrReturn)

```tsx
// Bad ❌
function getOos() {
  if (oos == null) {
    oos = new OjectOutput();
  }

  return oos;
}

// Good ✅
function createOrReturnOos() {
  if (oos == null) {
    oos = new OjectOutput();
  }

  return oos;
}
```

<br />

## 테스트

### T1: 불충분한 테스트

테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다. 테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.

### T7: 실패 패턴을 살펴라

때로는 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수 있다.

### T9: 테스트는 빨라야 한다

테스트 케이스가 빨리 돌아가게 최대한 노력해야 한다.
