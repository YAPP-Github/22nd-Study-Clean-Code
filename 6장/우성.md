# 객체와 자료 구조

## 자료 추상화

```js
// 6-1 구체적인 클래스
public class Point {
    public double x;
    public double y;
}

// 6-2 추상적인 클래스
public interface Point {
    getX();
    getY();
    void setCartesian(double x, double y);
    double getR();
    double getTheta();
    void setPolar(double r, double theta);
}
```

6-2 예시는 직교좌표계를 사용하는지 극좌표계를 사용하는지 알 길이 없다. 클래스 메서드가 접근 정책을 강제했기 때문이다.

반면 6-1 예시는 확실히 직교좌표계를 사용한다. 이 예시는 구현을 노출한다. 변수를 `privite`으로 선언하더라도 각 값마다 조회(get)함수와 설정(set)함수를 제공한다면 구현을 외부로 노출하는 셈이다.

구현을 감추려면 추상화가 필요하다. 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 한다.

인터페이스나 조회/설정만으로 추상화가 되지 않는다. 자료를 세세하게 표현하기보다는 추상적인 개념이 더 좋은데, 이 부분은 개발자가 고민을 많이 해야 한다.

<br />
<br />

## 자료/객체 비대칭

- 절차 지향: 새로운 함수가 필요한 경우
- 객체 지향: 새로운 자료 타입이 필요한 경우

객체 지향에서 어려운 변경은 절차 지향에서도 어려우며, 반대도 마찬가지다. 때로는 단순한 자료 구조와 절차적인 코드가 절적히 있는 것이 좋은 프로그래밍이다.

<br />
<br />

## 디미터 법칙

`모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다.` 객체는 자료를 숨기고, 함수를 공개한다.

디미터 법칙에 의거하면 클래스의 메서드 f는 다음과 같은 객체의 메서드만 호출해야 한다.

- class
- f가 생성한 객체
- f 인수로 넘어온 객체
- class 인스턴스 변수에 저장된 객체

### 기차 충돌

```js
const outputDir = ctx.getOptions().getScratch().getAbsolute();
```

위와 같은 코드를 기차 충돌이라고 부른다. 위와 같은 조합은 피하는 것이 좋다.

<br />
<br />

## 자료 전달 객체

- 공개 변수만 있고 함수가 없는 클래스(DTO, Data Transfer Object)
- 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다.
- 데이터베이스에 저장된 가공되지 않은 정보를 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체이다.

<br />
<br />

## 결론

객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 새 동작을 추가하기는 어렵다.

자료구조는 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
